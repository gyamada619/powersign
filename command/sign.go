package command

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/kyokomi/emoji"
)

type SignCommand struct {
	Meta
}

func (c *SignCommand) Run(args []string) int {

	uploadURL := args[0]
	fileToUpload := args[1]

	file, err := os.Open(fileToUpload)
	if err != nil {
		fmt.Println("File open error : ", err)
		os.Exit(-1)
	}

	defer file.Close()

	// since we are not going to upload our file with a Web browser or curl -F
	// we need to prepare a "virtual form" -- similar to what you can visually see
	// on localhost:8888 generated by receiveSubmission.go

	fileInfo, _ := file.Stat()

	var fileBody bytes.Buffer
	writer := multipart.NewWriter(&fileBody)

	// https://golang.org/pkg/mime/multipart/#Writer.CreateFormFile
	// must match what is expected by the receiving program
	// so, set field to "fileUploadName" for easier life...

	filePart, err := writer.CreateFormFile("fileUploadName", fileInfo.Name())
	if err != nil {
		fmt.Println("CreateFormFile error : ", err)
		os.Exit(-1)
	}

	// remember we are using mime - multipart
	_, err = io.Copy(filePart, file)

	if err != nil {
		fmt.Println("io.Copy error : ", err)
		os.Exit(-1)
	}

	// populate our header with simple data
	_ = writer.WriteField("Script To Sign", "Signature needed.")

	// remember to close writer
	err = writer.Close()
	if err != nil {
		fmt.Println("Writer close error : ", err)
		os.Exit(-1)
	}

	// ok, our "virtual form" is ready, time to submit our fileBody to
	// http://localhost:8888/submit with POST

	request, err := http.NewRequest("POST", uploadURL, &fileBody)
	if err != nil {
		fmt.Println("POST ERROR : ", err)
		os.Exit(-1)
	}

	// set the header with the proper content type for the fileBody's boundary
	// see https://golang.org/pkg/mime/multipart/#Writer.FormDataContentType

	request.Header.Set("Content-Type", writer.FormDataContentType())

	// upload/post/submit the file
	// with 10 seconds timeout
	client := &http.Client{Timeout: time.Second * 20}

	response, err := client.Do(request)
	if err != nil {
		fmt.Println("Client POST error : ", err)
		os.Exit(-1)
	}

	defer response.Body.Close()

	// Read response body
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		fmt.Println("Error reading body of response.", err)
		os.Exit(-1)
	}

	confirmation := string(body)
	fmt.Println(confirmation)

	if strings.Contains(confirmation, "successfully") {

		url := "http://localhost:7974/?file=" + fileInfo.Name()
		filepath := fileInfo.Name()
		// Get the data
		resp, err := http.Get(url)
		if err != nil {
			fmt.Println(err)
		}
		defer resp.Body.Close()

		// Create the file
		out, err := os.Create(filepath)
		if err != nil {
			fmt.Println(err)
		}
		defer out.Close()

		// Write the body to file
		_, err = io.Copy(out, resp.Body)
		Message := emoji.Sprint("Signed script downloaded to local machine's working directory :white_check_mark:")
		fmt.Println(Message)

		// Remove the signed file from the remote server
		purgeurl := "http://localhost:7974/delete?file=" + fileInfo.Name()
		resp, err = http.Get(purgeurl)
		if err != nil {
			fmt.Println(err)
		}
		_ = resp

		PurgeMessage := emoji.Sprint("Signed script removed from remote server :white_check_mark:\n")
		fmt.Println(PurgeMessage)
	}
	return 0
}

func (c *SignCommand) Synopsis() string {
	return "Upload a PowerShell script to sign to a PowerTrust listener."
}

func (c *SignCommand) Help() string {
	helpText := `

`
	return strings.TrimSpace(helpText)
}
